vim高级技巧之生成序列
https://segmentfault.com/a/1190000011104777

Vim 操作实用案例分析（一）：批量在行首或行尾添加内容
https://segmentfault.com/a/1190000023049904?utm_source=tag-newest

https://vim.ink

shuf
shuf -e a b c d
shuf /etc/passwd

sort
	-t #<==分隔符
	-k #<==指定排序的字段
	-n #<==按数字排序
	-r #<==降序，默认升序
	-f #<==忽略大小写
	-u #<==重复行只保留一行

sort -t: -k3 -n -r /etc/password

uniq



虚拟机，隔离资源；

容器：基础工具，生活中随处可见，可以[部分封闭]或[完全封闭]，被用于[容纳]、[储存]、[保护]、[运输]物品。
Host Virtualization
Hardware --> HostOS --> Hypervisor --> GuestOS[#] --> User Space[#]
Container
Hardware --> HostOS --> Container[#] --> User Space[#] 

FreeBSD jails，FreeBSD平台上一种基于容器的虚拟化技术，是对UNIX传统chroot机制的扩充，在FreeBSD jails中一个jail就是一个容器，每个jail都有自己的文件系统，进程和网络空间；
Linux-VServer，操作系统级虚拟化，用于虚拟操作系统内核，可以有多个用户空间，也称作虚拟专用服务器（VPS），各个VPS独立运行，Linux-VServer通过修改内核隔离用户空间；

一个用户空间具备：
NameSpace	系统调用参数	内核版		本隔离内容
-------------------------------------------------------
UTS			CLONE_NEWUTS	2.6.19		主机名和域名
IPC			CLONE_NEWIPC	2.6.19		信号量、消息队列和共享内存
PID			CLONE_NEWPID	2.6.24		进程编号
Network		CLONE_NEWNET	2.6.29		网络设备、网络栈、端口等
Mount		CLONE_NEWNS		2.4.19		挂载点（文件系统）
User		CLOEN_NEWUSER	3.8			用户和用户组


Linux系统中的两颗树：
	进程树（INIT）
	文件树（目录树）

用户空间：
	1. 保护进程；
	2. 给进程提供运行环境；

名称空间，namespace

资源隔离的两种技术：
主机级虚拟化
容器级虚拟化（chroot，NameSpace，CGroup）
	用户资源分配，cgroup（Control Group）

cgroups：
blkio：块设备IO；
cpu：CPU；
cpuacct：cpu资源使用报告；
cpuset：多处理器平台上的cpu集合；
devices：设备访问；
freezer：挂起或恢复任务；
memory：内存用量及报告；
perf_event：对cgroups中的任务进行统一性能测试；
net_cls：cgroups中的任务创建的数据报文的类别标识符，网络报文标识符；



在虚拟化中，cpu是可压缩资源，内存是非可压缩资源；

容器的隔离性远不如虚拟机好，虚拟机是单独的内核，容器是共享一个内核；

LXC：LinuX Container 
LXC简化了容器使用的复杂性，隔离无法保证；
LXC好处在于能让用户空间的进程直接使用宿主机的性能（资源），没有其他而外开销。

lxc-create：创建用户空间（容器）；
lxc-template：一组脚本，实现自动安装过程；

docker是LXC的增强版
	用LXC做容器管理引擎，安装容器不在使用LXC的template安装生成，而是使用一种镜像技术；
	docker让一个容器只运行一个进程；
	LXC把容器当虚拟机使用，可以运行多个进程；

容器的宗旨是最小（少）化，容器内部只有保证进程运行所需要的文件，但需要对容器内的进程进行调试会很麻烦。

发布容器（编排工具）：对有依赖关系的容器，启动次序有要求。

docker镜像的构建：分层构建，联合挂载；
docker镜像都是只读的。
	如果需要删除镜像中的文件，把需要删除的文件标记为不可见；
	如果需要修改镜像中的文件，把需要修改的文件读取到可修改层进行修改；
	将需要持久化（断电也保存）的数据保存在外部共享存储上；
	容器不需要持久，有生命周期；

编排：在docke主机上构建一层，启动容器并决定容器运行在那个docker主机上，挂载外部存储，对有依赖关系的容器，其启动次序也有要求进行启动。

machine + swarm + compose ：单机编排工具
	machine：创建Docker环境的机器；
	swarm：完成多台机器之间容器集群的管理，Swarm是docker自带的一种模式，内嵌到docker里。
	compose：可以有组织的启动同属于一个服务的多个容器，通过yaml文件预先配置；

mesos+ marathon ：统一资源调度和分配，可实现编排；
	Mesos：集群资源管理系统；
	marathon：运行在Mesos之上的集群计算架构。

libcontainer：runC，替代了LXC；
	Libcontainer是Docker中用于容器管理的包，它基于Go语言实现，通过管理namespace、cgroups、capabilities以及文件系统来进行容器控制。可以使用libcontainer创建容器，并对容器进行生命周期管理。

docker中的容器：
lxc --> libcontainer --> runC

OCI（Open Container Initiative）
由Linux基金会主导于2015年6月创立，旨在围绕容器格式和运行时制定一个开放的工业化标准；
container two specifications:
	the Runtime Specification (runtime-spec)
	the Image Specification (image-spec)

OCF：Open Container Format
runC : Is a CLI tool for spawwning and running containers according to the OCI specification.

docker镜像站点：https://hub.docker.com/
docker c/s架构
	docker daemon
		ipv4
		ipv6
		unix socket file（本地文件）
docker_host：真正运行容器的主机；

docker daemon
containers
images <--http/https--> registry (dockerhub.com)

client <--http/https--> docker_host

docker公司推出两个产品，docker ee和docker ce，并将Github上原属于Docker组织的Docker项目直接transfer到一个新的、名叫Moby的组织下，并将其命名为Moby项目。
CNCF（Cloud Native Computing Foundation）于 2015 年 7 月成立，隶属于 Linux 基金会，初衷围绕“云原生”服务云计算，致力于维护和集成开源技术，支持编排容器化微服务架构应用。它是一个非营利组织，致力于通过技术优势和用户价值创造一套新的通用容器技术，推动本土云计算和服务的发展。CNCF 关注于容器如何管理而不是如何创建。CNCF包含了Kubernetes、Prometheus和gRPC等多个云端原生技术项目项目。
Kubernetes：缩写成K8S，前身是Borg，Google发起并维护的基于Docker的开源容器集群管理系统，构建于Docker技术之上，为容器化的应用提供资源调度、部署运行、服务发现、扩容缩容等一整套功能。是一套基于容器技术的mini-PaaS平台，k8s属于主从的分布式集群架构，包含Master和Node；
Prometheus：一套开源的监控、报警和时间序列数据库的组合。
Open Tracing
Fluentd
gRPC：在 gRPC 里客户端应用可以像调用本地对象一样直接调用另一台不同的机器上服务端应用的方法，使得您能够更容易地创建分布式应用和服务。与许多 RPC 系统类似，gRPC 也是基于以下理念：定义一个服务，指定其能够被远程调用的方法（包含参数和返回类型）。在服务端实现这个接口，并运行一个 gRPC 服务器来处理客户端调用。在客户端拥有一个存根能够像服务端一样的方法。


Moby
	docker_ee：企业版
	docker_ce：社区版

docker architecture
	docker daemon（增删改查）
		image
		container
		network
		volume
		plugins
	docker client
	docker registries（images）：有多个仓库repository，提供image，提供认证，提供搜索索引；
		位置：
			docker hub
			docker clound
		功能：
			提供image；
			提供认证；
			提供搜索索引；
		特点：
			仓库内只放一种应用程序；
			仓库名就是应用程序名；
			每个版本添加标签（tag）；
			一个image如果没有指定标签代表是最新版；
			latest，最新版；
			stable，最新稳定版；
			alpine，用于构建小的image的微型发行版，缺少调试工具；

Client <--> Docker Host <--> Registry

Clinet
	docker build
	docker pull
	docker run
	...
Docker Host
	Docker daemon
		Container
		Image

Registry
image和容器的关系就像程序和进程的关系。image是静态的，容器是动态的，有生命周期；

docker的配置文件（需要手动建立）：/etc/docker/daemon.json

依赖的基础环境：
	64 bits CPU
	Linux Kernel 3.10+
	Linux Kernel support cgroups and namespaces
安装
	"Extras" repository

https://mirrors.tuna.tsinghua.edu.cn

docker安装后会自动创建一个网络设备 docker0，网段是172.17.0.0。任何启动的容器会自动拥有这个网桥（docker0），并且是net bridge，地址转换桥。

配置Docker镜像加速
vim   /etc/docker/daemon.json
docker-cn 官方 : https://registry.docker-cn.com
中科大 : https://docker.mirrors.ustc.edu.cn

tee /etc/docker/daemon.json <<-'EOF'
{
    "registry-mirrors": [
        "https://docker.mirrors.ustc.edu.cn",
        "https://registry.docker-cn.com"
    ]
}
EOF
sudo systemctl daemon-reload
sudo systemctl restart docker

启动服务
systemctl start docker.service
systemctl enable docker.service

docker version
docker info

docker image pull nginx:1.14-alpine
docker image pull busybox

docker network ls

docker run -it --name bb1 busybox:latest
创建一个容器所使用的Image不需要提前下载；
？在容器中的任何程序不能让它运行在后台，运行在后台就终止；

mkdir -p /data/html/
vim  /data/html/index.html
"Busybox httpd Server."
httpd -h /data/html/
netstat -tlnup

在宿主机上执行：
docker inspect bb1  #<===查看bb1的IP
curl 172.17.0.2

在容器里执行exit后会把容器挂起，
docker ps
docker ps -a

重新启动挂起的doccker
docker container start -i -a web1
docker container start -i -a bb1

Kill一个或多个up状态的docker
docker container kill web1
docker container kill bb1

删除一个docker
docker container rm web1
docker container rm bb1

docker search : Search the Docker Hub images;
docker pull : Pull an image or a repository from a registry;
docker images : List images;
docker create : Create a new container;
docker start : Start one or more stopped containers;
docker run : Run a command in a new container;
docker attach : Attach to a running container;
docker ps : List containers;
docker logs : Fetch the logs of a container;
docker restart : Restart a container;
docker stop : Stop one or more running containers;
docker kill : Kill one or more running containers;
docker rm : Remove one or more containers;

docker container在不同状态下可执行的命令：
created状态：
	docker container start    #--> running 状态
	docker container rm       #--> deleted 状态
running状态：
	docker container kill     #--> stopped 状态
	docker container stop     #--> stoppd 状态
	docker container restart  #--> running 状态
	docker container pasue    #--> paused 状态
paused状态：
	docker container unpasue  #--> running 状态
stopped状态：
	docker container start    #--> running 状态
	docker container rm       #--> deleted 状态
deleted状态：



docker是容器，容器不一定是docker






===============================================================================
===============================================================================
===============================================================================
03-Docker镜像管理基础

Docker Daemon启动
Docker Daemon监听到命令后可以创建多个容器；
容器创建依赖于Image；
如果本地没有Image，会从Registries上使用http/https协议下载；
在docker版本大于等于18上容器存储的驱动器使用overlay2；

docker container exec -it rd1 /bin/sh

由于Aufs代码质量不佳（四五万行），CentOS没有讲Aufs代码放入内核，Ubuntu在内核中使用了Aufs。
Docker daemon默认使用https，如果要使用http，需要配置；

如果不明确指明，Registry是dockershub；

vmware   harbor
Sponsor Registry:
Mirror Registry: 镜像加速
Vendor Registry:服务商的registry，不提供给所有人使用
Private Registry:

一个镜像可以有多个Tag，一个Tag只能属于一个镜像；

base image 由docker hub工作人员制作

在本地创建dockerfile
完成后pull到Github的仓库中；
Docker hub会和Github由联动；
Docker hub发现Github中的dockerfile有变化；
会自动将Github中的dockerfile拉到Docker hub仓库中
构架镜像

https://quay.io
https://docs.quay.io
flannel

docker pull quay.io/coreos/flannel

Image的创建：
Dockerfile：基于dockers file，使用dockers builder命令
基于container，使用docker container commit 命令
Docker Hub automated builds : 还是基于Dockerfile，

实例，基于container 创建 image
docker container run -it --name b1 busybox
	mkdir -p  /data/html
	vi /data/html/index.html
	<h1>Busybox httpd server.</h1>

docker container commit -p b1 
docker container commit -p b1 busybox-http:0.1

给image添加tag
docker tag 2994ce018a61 alita/tools/http-busybox:0.1
docker tag 2994ce018a61 alita/tools/http-busybox:0.1-1

产看image中cmd字段值：
docker inspect  busybox-http:0.1

docker container commit -a "CongJun <CJo_126@126.com>" -c 'CMD ["/bin/httpd","-f","-h","/data/html"]' -p bh1 busybox-http:0.2

国内image：
https://dev.aliyun.com/search.html











[root@docker01☻ ~]# docker login -u cdockerj
Password:
WARNING! Your password will be stored unencrypted in /root/.docker/config.json.
Configure a credential helper to remove this warning. See
https://docs.docker.com/engine/reference/commandline/login/#credentials-store

Login Succeeded
[root@docker01☻ ~]# docker images
REPOSITORY                 TAG                 IMAGE ID            CREATED             SIZE
busybox-http               0.2                 0ac701def142        13 minutes ago      1.22MB
busybox-http               0.1                 3c4ea84c263b        52 minutes ago      1.22MB
alita/tools/http-busybox   0.1                 2994ce018a61        53 minutes ago      1.22MB
alita/tools/http-busybox   0.1-1               2994ce018a61        53 minutes ago      1.22MB
busybox                    latest              018c9d7b792b        4 weeks ago         1.22MB
nginx                      1.18-alpine         8c1bfa967ebf        6 weeks ago         21.5MB
redis                      4-alpine            e3dd0e49bca5        4 months ago        20.4MB
quay.io/coreos/flannel     v0.12.0-arm64       7cf4a417daaa        5 months ago        53.6MB
nginx                      1.14-alpine         8a2fb25a19f5        16 months ago       16MB
[root@docker01☻ ~]# docker tag busybox-http:0.2 cdockerj/http:v0.1
[root@docker01☻ ~]# docker images
REPOSITORY                 TAG                 IMAGE ID            CREATED             SIZE
cdockerj/http              v0.1                0ac701def142        15 minutes ago      1.22MB
busybox-http               0.2                 0ac701def142        15 minutes ago      1.22MB
busybox-http               0.1                 3c4ea84c263b        55 minutes ago      1.22MB
alita/tools/http-busybox   0.1                 2994ce018a61        56 minutes ago      1.22MB
alita/tools/http-busybox   0.1-1               2994ce018a61        56 minutes ago      1.22MB
busybox                    latest              018c9d7b792b        4 weeks ago         1.22MB
nginx                      1.18-alpine         8c1bfa967ebf        6 weeks ago         21.5MB
redis                      4-alpine            e3dd0e49bca5        4 months ago        20.4MB
quay.io/coreos/flannel     v0.12.0-arm64       7cf4a417daaa        5 months ago        53.6MB
nginx                      1.14-alpine         8a2fb25a19f5        16 months ago       16MB
[root@docker01☻ ~]# docker push cdockerj/http
The push refers to repository [docker.io/cdockerj/http]
3512654a9ded: Pushed
1c81f41a7308: Pushed
514c3a3e64d4: Mounted from library/busybox
v0.1: digest: sha256:9328063df8c55e23848b12061791addd752da053b412082fb46aa988fc466375 size: 941
[root@docker01☻ ~]#
[root@docker01☻ ~]#
[root@docker01☻ ~]# tee /etc/docker/daemon.json <<-'EOF'
> {
>   "registry-mirrors": ["https://tx5kz423.mirror.aliyuncs.com"]
> }
> EOF
{
  "registry-mirrors": ["https://tx5kz423.mirror.aliyuncs.com"]
}
[root@docker01☻ ~]# ls
daemon.json  key.json
[root@docker01☻ ~]# systemctl daemon-reload
[root@docker01☻ ~]# systemctl restart docker
[root@docker01☻ ~]# docker images
REPOSITORY                 TAG                 IMAGE ID            CREATED             SIZE
cdockerj/http              v0.1                0ac701def142        28 minutes ago      1.22MB
busybox-http               0.2                 0ac701def142        28 minutes ago      1.22MB
busybox-http               0.1                 3c4ea84c263b        About an hour ago   1.22MB
alita/tools/http-busybox   0.1                 2994ce018a61        About an hour ago   1.22MB
alita/tools/http-busybox   0.1-1               2994ce018a61        About an hour ago   1.22MB
busybox                    latest              018c9d7b792b        4 weeks ago         1.22MB
nginx                      1.18-alpine         8c1bfa967ebf        6 weeks ago         21.5MB
redis                      4-alpine            e3dd0e49bca5        4 months ago        20.4MB
quay.io/coreos/flannel     v0.12.0-arm64       7cf4a417daaa        5 months ago        53.6MB
nginx                      1.14-alpine         8a2fb25a19f5        16 months ago       16MB
[root@docker01☻ /etc/docker]# docker login --username=被武松打死的老虎 registry.cn-hangzhou.aliyuncs.com
Password:
WARNING! Your password will be stored unencrypted in /root/.docker/config.json.
Configure a credential helper to remove this warning. See
https://docs.docker.com/engine/reference/commandline/login/#credentials-store

Login Succeeded
[root@docker01☻ /etc/docker]# docker push registry.cn-hangzhou.aliyuncs.com/cdockerj/http
The push refers to repository [registry.cn-hangzhou.aliyuncs.com/cdockerj/http]
An image does not exist locally with the tag: registry.cn-hangzhou.aliyuncs.com/cdockerj/http
[root@docker01☻ /etc/docker]# docker push registry.cn-hangzhou.aliyuncs.com/cdockerj/http
The push refers to repository [registry.cn-hangzhou.aliyuncs.com/cdockerj/http]
An image does not exist locally with the tag: registry.cn-hangzhou.aliyuncs.com/cdockerj/http
[root@docker01☻ /etc/docker]# docker images
REPOSITORY                 TAG                 IMAGE ID            CREATED             SIZE
busybox-http               0.2                 0ac701def142        32 minutes ago      1.22MB
cdockerj/http              v0.1                0ac701def142        32 minutes ago      1.22MB
busybox-http               0.1                 3c4ea84c263b        About an hour ago   1.22MB
alita/tools/http-busybox   0.1                 2994ce018a61        About an hour ago   1.22MB
alita/tools/http-busybox   0.1-1               2994ce018a61        About an hour ago   1.22MB
busybox                    latest              018c9d7b792b        4 weeks ago         1.22MB
nginx                      1.18-alpine         8c1bfa967ebf        6 weeks ago         21.5MB
redis                      4-alpine            e3dd0e49bca5        4 months ago        20.4MB
quay.io/coreos/flannel     v0.12.0-arm64       7cf4a417daaa        5 months ago        53.6MB
nginx                      1.14-alpine         8a2fb25a19f5        16 months ago       16MB
[root@docker01☻ /etc/docker]# docker tag busybox-http registry.cn-hangzhou.aliyuncs.com/cdockerj/http:0.1
Error response from daemon: No such image: busybox-http:latest
[root@docker01☻ /etc/docker]# docker tag busybox-http:0.2 registry.cn-hangzhou.aliyuncs.com/cdockerj/http:0.1
[root@docker01☻ /etc/docker]# dock
[root@docker01☻ /etc/docker]#
[root@docker01☻ /etc/docker]# docker push registry.cn-hangzhou.aliyuncs.com/cdockerj/http
The push refers to repository [registry.cn-hangzhou.aliyuncs.com/cdockerj/http]
3512654a9ded: Pushed
1c81f41a7308: Pushed
514c3a3e64d4: Pushed
0.1: digest: sha256:9328063df8c55e23848b12061791addd752da053b412082fb46aa988fc466375 size: 941
[root@docker01☻ /etc/docker]#


打包/导入镜像
docker image save -o /tmp/image.gz cdockerj/http:v0.1 redis:4-alpine

docker image load -i /tmp/image.gz









===============================================================================
===============================================================================
===============================================================================
04-容器虚拟化网络概述

Linux内核支撑两种设备的模拟：
二层设备（网卡），虚拟网卡成对出现，模拟为一根网线的两头。
linux原生支持二层网桥设备，虚拟一个二层交换机。
三层设备（路由器）

SDN：软件 定义/驱动 的网络

一台主机上多个容器需要网络通信：
1、在这台主机上创建一台虚拟交换机；
2、在每个容器上创建虚拟网卡，一头连接容器，一头连接虚拟交换机；
如果不同的容器属于不同的网段：
c1，c2容器连接到虚拟的s1交换机上；
c3，c4容器连接到虚拟的s2交换机上；
因为linux内核支持路由功能，所以在创建一个容器c5，用作路由器，只有linux内核，s1和s2都连接到c5上。
如果不创建c5，使用iptables规则也可以实现ip的转发。

桥接：把物理网卡当交换机来用。
桥接设备过多会产生风暴。

物理主机1上有容器c3、c4，连接到虚拟交换机s2上；
物理主机2上有容器c5、c6，连接到虚拟交换机s2上；
c3要和c5通信：
c3把网关指向s2，c3报文通过s2发到物理主机1上的地址H1，物理主机1内核开通报文转发，物理主机1将报文发送到物理主机2上的地址H2，物理主机2通过NAT将报文发送到c5；

如果c3使用私有地址，无法收到c5的返回报文，除非物理主机1上开通了nat；

c3把网关指向s2，c3把报文发送到s2；
物理主机1通过NAT将c3的私有地址转换为H1；
物理主机1将报文转发到物理主机2的H2地址上；
物理主机2通过NAT将H2的地址接收到的报文转换为c5的私有地址；
将报文发送到c5；

两台物理主机上容器通信面临两级NAT，效率低下。

Overlay Network（叠加网络）
隧道：用一个IP承载另一个IP。
物理机上创建
虚拟机上做一个虚拟的桥，各容器连接到这个桥
容器通信时通过物理网卡的隧道转发
报文格式：
[c1的IP|c5的IP][h1的IP|h2的IP]
两级三层封装

docker network ls
ifconfig 
docker0 : 虚拟的交换机，二层的网卡设备，没有配地址就是交换机，配地址既能做交换机也能做网卡。docker0桥默认时net桥；
每启动一个容器，就分配一对网卡设备，一端在容器上，一端在docker0上。
物理机把docker0当作网卡，容器把docker0当作交换机。

yum -y install bridge-utils
brctl show
ip link show

进入容器查看网络信息
docker container exec -it b1 /bin/sh
ifconfig
ip link show



[root@docker01☻ ~]# iptables -t nat -vnL
Chain PREROUTING (policy ACCEPT 9 packets, 688 bytes)
 pkts bytes target     prot opt in     out     source               destination
    2   136 DOCKER     all  --  *      *       0.0.0.0/0            0.0.0.0/0            ADDRTYPE match dst-type LOCAL

Chain INPUT (policy ACCEPT 8 packets, 604 bytes)
 pkts bytes target     prot opt in     out     source               destination

Chain OUTPUT (policy ACCEPT 40 packets, 2591 bytes)
 pkts bytes target     prot opt in     out     source               destination
    0     0 DOCKER     all  --  *      *       0.0.0.0/0           !127.0.0.0/8          ADDRTYPE match dst-type LOCAL

Chain POSTROUTING (policy ACCEPT 41 packets, 2675 bytes)
 pkts bytes target     prot opt in     out     source               destination
    0     0 MASQUERADE  all  --  *      !docker0  172.17.0.0/16        0.0.0.0/0

Chain DOCKER (2 references)
 pkts bytes target     prot opt in     out     source               destination
    1    84 RETURN     all  --  docker0 *       0.0.0.0/0            0.0.0.0/0

wget  -O - -q http://172.17.0.3
curl http://172.17.0.3

每个容器都有独立的六个名称空间：
User, Mount, Pid
UTS, Net, IPC

容器和容器间可以共享名称空间
所以
每个容器有三个独立的名称空间：User, Mount, Pid
每个容器共享这三个名称空间：UTS, Net, IPC，可以使用127.0.0.1访问不同容器上的服务（端口不同）；

容器也可以和宿主机共享名称空间；
一个容器和宿主机共享Net名称空间，这个容器可以控制、配置宿主机机的网络配置；
其他容器使用桥接网络

[root@docker01☻ ~]# docker network ls
NETWORK ID          NAME                DRIVER              SCOPE
2cf62895ac12        bridge              bridge              local
0f00c40728a9        host                host                local
071c0dffdcc8        none                null                local

bridge：桥接网络，创建容器即分配一对网卡，一头在容器，另外一头在docker0
host：容器和宿主机共享网络命名空间；
noen：容器不需要网络；

docker一共有四种网络模型：
Closed container
Bridged container（默认），net桥，不是物理桥
Joined container
Open container

docker network inspect bridge


===============================================================================
===============================================================================
===============================================================================
05-Docker容器网络

ip命令的netns就指网络名称空间
[root@docker02☻ ~]# ip netns help
Usage: ip netns list
       ip netns add NAME
       ip netns set NAME NETNSID
       ip [-all] netns delete [NAME]
       ip netns identify [PID]
       ip netns pids NAME
       ip [-all] netns exec [NAME] cmd ...
       ip netns monitor
       ip netns list-id
[root@docker02☻ ~]#

创建一个veth类型的网络设备
ip link add name veth1.1 type veth peer name veth1.2

[root@docker02☻ ~]# ip link add name veth1.1 type veth peer name veth1.2
[root@docker02☻ ~]# ip link show
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
2: ens32: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000
    link/ether 00:0c:29:1b:48:21 brd ff:ff:ff:ff:ff:ff
3: docker0: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc noqueue state DOWN mode DEFAULT group default
    link/ether 02:42:9a:8f:5e:ba brd ff:ff:ff:ff:ff:ff
4: veth1.2@veth1.1: <BROADCAST,MULTICAST,M-DOWN> mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000
    link/ether 6a:af:c5:1f:b1:54 brd ff:ff:ff:ff:ff:ff
5: veth1.1@veth1.2: <BROADCAST,MULTICAST,M-DOWN> mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000
    link/ether e2:5a:56:d4:9b:2c brd ff:ff:ff:ff:ff:ff

将创建的veth1.2挪到网络名称空间ns1中去
[root@docker02☻ ~]# ip link set dev veth1.2 netns ns1
[root@docker02☻ ~]#
[root@docker02☻ ~]# ip link show
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
2: ens32: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000
    link/ether 00:0c:29:1b:48:21 brd ff:ff:ff:ff:ff:ff
3: docker0: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc noqueue state DOWN mode DEFAULT group default
    link/ether 02:42:9a:8f:5e:ba brd ff:ff:ff:ff:ff:ff
5: veth1.1@if4: <BROADCAST,MULTICAST> mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000
    link/ether e2:5a:56:d4:9b:2c brd ff:ff:ff:ff:ff:ff link-netnsid 0
[root@docker02☻ ~]#
[root@docker02☻ ~]# ip netns exec ns1 ip link show
1: lo: <LOOPBACK> mtu 65536 qdisc noop state DOWN mode DEFAULT group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
4: veth1.2@if5: <BROADCAST,MULTICAST> mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000
    link/ether 6a:af:c5:1f:b1:54 brd ff:ff:ff:ff:ff:ff link-netnsid 0
[root@docker02☻ ~]# ip netns exec ns1 ifconfig -a
lo: flags=8<LOOPBACK>  mtu 65536
        loop  txqueuelen 1000  (Local Loopback)
        RX packets 0  bytes 0 (0.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 (0.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

veth1.2: flags=4098<BROADCAST,MULTICAST>  mtu 1500
        ether 6a:af:c5:1f:b1:54  txqueuelen 1000  (Ethernet)
        RX packets 0  bytes 0 (0.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 (0.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

[root@docker02☻ ~]#

修改net名称空间中网卡名称
ip netns exec ns1 ip link set dev veth1.2 name eth0

[root@docker02☻ ~]# ip netns exec ns1 ip link show
1: lo: <LOOPBACK> mtu 65536 qdisc noop state DOWN mode DEFAULT group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
4: veth1.2@if5: <BROADCAST,MULTICAST> mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000
    link/ether 6a:af:c5:1f:b1:54 brd ff:ff:ff:ff:ff:ff link-netnsid 0
[root@docker02☻ ~]# ip netns exec ns1 ip link set dev veth1.2 name eth0
[root@docker02☻ ~]# ip netns exec ns1 ip link show
1: lo: <LOOPBACK> mtu 65536 qdisc noop state DOWN mode DEFAULT group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
4: eth0@if5: <BROADCAST,MULTICAST> mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000
    link/ether 6a:af:c5:1f:b1:54 brd ff:ff:ff:ff:ff:ff link-netnsid 0
[root@docker02☻ ~]#

[root@docker02☻ ~]# ifconfig veth1.1 10.1.0.1/24 up
[root@docker02☻ ~]# ifconfig
docker0: flags=4099<UP,BROADCAST,MULTICAST>  mtu 1500
        inet 172.17.0.1  netmask 255.255.0.0  broadcast 172.17.255.255
        ether 02:42:9a:8f:5e:ba  txqueuelen 0  (Ethernet)
        RX packets 0  bytes 0 (0.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 (0.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

ens32: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 192.168.23.112  netmask 255.255.255.0  broadcast 192.168.23.255
        inet6 fe80::24b8:6e2c:8bdb:fdb6  prefixlen 64  scopeid 0x20<link>
        inet6 fe80::ed30:5392:a000:f088  prefixlen 64  scopeid 0x20<link>
        ether 00:0c:29:1b:48:21  txqueuelen 1000  (Ethernet)
        RX packets 2680  bytes 203490 (198.7 KiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 1541  bytes 200522 (195.8 KiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

lo: flags=73<UP,LOOPBACK,RUNNING>  mtu 65536
        inet 127.0.0.1  netmask 255.0.0.0
        inet6 ::1  prefixlen 128  scopeid 0x10<host>
        loop  txqueuelen 1000  (Local Loopback)
        RX packets 0  bytes 0 (0.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 (0.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

veth1.1: flags=4099<UP,BROADCAST,MULTICAST>  mtu 1500
        inet 10.1.0.1  netmask 255.255.255.0  broadcast 10.1.0.255
        ether e2:5a:56:d4:9b:2c  txqueuelen 1000  (Ethernet)
        RX packets 0  bytes 0 (0.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 (0.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

[root@docker02☻ ~]# ip netns exec ns1 ifconfig eth0 10.1.0.2/24 up
[root@docker02☻ ~]# ip netns exec ns1 ifconfig
eth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 10.1.0.2  netmask 255.255.255.0  broadcast 10.1.0.255
        inet6 fe80::68af:c5ff:fe1f:b154  prefixlen 64  scopeid 0x20<link>
        ether 6a:af:c5:1f:b1:54  txqueuelen 1000  (Ethernet)
        RX packets 7  bytes 586 (586.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 7  bytes 586 (586.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

[root@docker02☻ ~]# ping 10.1.0.1
PING 10.1.0.1 (10.1.0.1) 56(84) bytes of data.
64 bytes from 10.1.0.1: icmp_seq=1 ttl=64 time=0.024 ms
^C
--- 10.1.0.1 ping statistics ---
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 0.024/0.024/0.024/0.000 ms
[root@docker02☻ ~]# ping 10.1.0.2
PING 10.1.0.2 (10.1.0.2) 56(84) bytes of data.
64 bytes from 10.1.0.2: icmp_seq=1 ttl=64 time=0.039 ms
^C
--- 10.1.0.2 ping statistics ---
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 0.039/0.039/0.039/0.000 ms
[root@docker02☻ ~]#


将veth1.1挪到ns2中
[root@docker02☻ ~]# ip link set dev veth1.1 netns ns2
[root@docker02☻ ~]# ip link show
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
2: ens32: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000
    link/ether 00:0c:29:1b:48:21 brd ff:ff:ff:ff:ff:ff
3: docker0: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc noqueue state DOWN mode DEFAULT group default
    link/ether 02:42:9a:8f:5e:ba brd ff:ff:ff:ff:ff:ff
[root@docker02☻ ~]# ip netns exec ns2 ip a s
1: lo: <LOOPBACK> mtu 65536 qdisc noop state DOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
5: veth1.1@if4: <BROADCAST,MULTICAST> mtu 1500 qdisc noop state DOWN group default qlen 1000
    link/ether e2:5a:56:d4:9b:2c brd ff:ff:ff:ff:ff:ff link-netnsid 0
[root@docker02☻ ~]# ip netns exec ns2 ifconfig
[root@docker02☻ ~]# ip netns exec ns2 ifconfig  -a
lo: flags=8<LOOPBACK>  mtu 65536
        loop  txqueuelen 1000  (Local Loopback)
        RX packets 0  bytes 0 (0.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 (0.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

veth1.1: flags=4098<BROADCAST,MULTICAST>  mtu 1500
        ether e2:5a:56:d4:9b:2c  txqueuelen 1000  (Ethernet)
        RX packets 11  bytes 838 (838.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 11  bytes 838 (838.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

[root@docker02☻ ~]# ip netns exec ns2 ifconfig veth1.1 10.1.0.3/24 up
[root@docker02☻ ~]# ping 10.1.0.1
PING 10.1.0.1 (10.1.0.1) 56(84) bytes of data.
^C
--- 10.1.0.1 ping statistics ---
1 packets transmitted, 0 received, 100% packet loss, time 0ms

[root@docker02☻ ~]# ping 10.1.0.2
PING 10.1.0.2 (10.1.0.2) 56(84) bytes of data.
^C
--- 10.1.0.2 ping statistics ---
1 packets transmitted, 0 received, 100% packet loss, time 0ms

[root@docker02☻ ~]# ping 10.1.0.3
PING 10.1.0.3 (10.1.0.3) 56(84) bytes of data.
^C
--- 10.1.0.3 ping statistics ---
1 packets transmitted, 0 received, 100% packet loss, time 0ms

[root@docker02☻ ~]# ip netns exec ns2 ifconfig
veth1.1: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 10.1.0.3  netmask 255.255.255.0  broadcast 10.1.0.255
        inet6 fe80::e05a:56ff:fed4:9b2c  prefixlen 64  scopeid 0x20<link>
        ether e2:5a:56:d4:9b:2c  txqueuelen 1000  (Ethernet)
        RX packets 11  bytes 838 (838.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 19  bytes 1494 (1.4 KiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

[root@docker02☻ ~]# ip netns exec ns2 ping 10.1.0.2
PING 10.1.0.2 (10.1.0.2) 56(84) bytes of data.
64 bytes from 10.1.0.2: icmp_seq=1 ttl=64 time=0.040 ms
64 bytes from 10.1.0.2: icmp_seq=2 ttl=64 time=0.038 ms
^C
--- 10.1.0.2 ping statistics ---
2 packets transmitted, 2 received, 0% packet loss, time 999ms
rtt min/avg/max/mdev = 0.038/0.039/0.040/0.001 ms
[root@docker02☻ ~]# ip netns exec ns2 ping 10.1.0.1
PING 10.1.0.1 (10.1.0.1) 56(84) bytes of data.
^C
--- 10.1.0.1 ping statistics ---
1 packets transmitted, 0 received, 100% packet loss, time 0ms

[root@docker02☻ ~]# ip netns exec ns2 ping 10.1.0.3
PING 10.1.0.3 (10.1.0.3) 56(84) bytes of data.
^C
--- 10.1.0.3 ping statistics ---
2 packets transmitted, 0 received, 100% packet loss, time 1000ms

[root@docker02☻ ~]#

[root@docker02☻ ~]# ip netns exec ns2 ifconfig
veth1.1: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 10.1.0.3  netmask 255.255.255.0  broadcast 10.1.0.255
        inet6 fe80::e05a:56ff:fed4:9b2c  prefixlen 64  scopeid 0x20<link>
        ether e2:5a:56:d4:9b:2c  txqueuelen 1000  (Ethernet)
        RX packets 14  bytes 1076 (1.0 KiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 25  bytes 1858 (1.8 KiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
网卡改名需要先down
[root@docker02☻ ~]# ip netns exec ns2 ip link set dev veth1.1 name eth0
RTNETLINK answers: Device or resource busy

docker container run --name t1 -it --rm busybox:latest
--rm：退出容器自动删除
docker container run --name t1 -it --network none   --rm busybox:latest
docker container run --name t1 -it --network bridge --rm busybox:latest
docker container run --name t1 -it --network bridge --rm -h b1 busybox:latest
	cat /etc/hosts
	cat /etc/resolv.conf
	nslookup -type=A www.baidu.com
docker container run --name t1 -it --network bridge --rm -h b1 --dns 114.114.114.114 busybox:latest
docker container run --name t1 -it --network bridge --rm -h b1 --dns 114.114.114.114 --dns-search ilinux.io busybox:latest
docker container run --name t1 -it --network bridge --rm -h b1 --dns 114.114.114.114 --dns-search ilinux.io --add-host www.name.com:3.3.3.3 busybox:latest

-p选项
动态端口：30000-32767

docker container run --name web1 --rm -p 80 busybox-httpd:v0.1
查看生成的随机端口
iptables -t nat -vnL
netstat -tlnup

[root@docker01☻ ~]# iptables -t nat -vnL                                                                                        
Chain PREROUTING (policy ACCEPT 1 packets, 60 bytes)                                                                            
 pkts bytes target     prot opt in     out     source               destination                                                 
    5   284 DOCKER     all  --  *      *       0.0.0.0/0            0.0.0.0/0            ADDRTYPE match dst-type LOCAL          
                                                                                                                                
Chain INPUT (policy ACCEPT 1 packets, 60 bytes)                                                                                 
 pkts bytes target     prot opt in     out     source               destination                                                 
                                                                                                                                
Chain OUTPUT (policy ACCEPT 0 packets, 0 bytes)                                                                                 
 pkts bytes target     prot opt in     out     source               destination                                                 
    0     0 DOCKER     all  --  *      *       0.0.0.0/0           !127.0.0.0/8          ADDRTYPE match dst-type LOCAL          
                                                                                                                                
Chain POSTROUTING (policy ACCEPT 1 packets, 60 bytes)                                                                           
 pkts bytes target     prot opt in     out     source               destination                                                 
   14  1001 MASQUERADE  all  --  *      !docker0  172.17.0.0/16        0.0.0.0/0                                                
    0     0 MASQUERADE  tcp  --  *      *       172.17.0.2           172.17.0.2           tcp dpt:80                            
                                                                                                                                
Chain DOCKER (2 references)                                                                                                     
 pkts bytes target     prot opt in     out     source               destination                                                 
    0     0 RETURN     all  --  docker0 *       0.0.0.0/0            0.0.0.0/0                                                  
    1    60 DNAT       tcp  --  !docker0 *       0.0.0.0/0            0.0.0.0/0            tcp dpt:4004 to:172.17.0.2:80        

docker container run --name web2 --rm -p 192.168.23.111::80 busybox-httpd:v0.1
::，两个冒号指任意端口。

docker container run --name web3 --rm -p 80:80 busybox-httpd:v0.1
将容器的80端口（后面的），映射到宿主机的80端口（前面的）上。

docker container run --name web3 --rm -p 192.168.23.111:80:80 busybox-httpd:v0.1

将容器web4上所有端口都映射出去
docker container run --name web4 --rm -P busybox-httpd:v0.1

docker container port web3


容器b1和容器b2共享net name space
docker container run --name b1 -it --rm busybox:latest
	echo b1 > /tmp/index.html
	httpd -h /tmp
	netstat -tlnup
docker container run --name b2 -it --rm --network container:b1 busybox:latest
	echo b2 > /tmp/index.html
	httpd -h /tmp

/ # echo b2 > /tmp/index.html
/ # httpd -h /tmp
httpd: bind: Address already in use
/ #

容器b1共享宿主机的net name space
docker container run --name b1 -it --rm --network host busybox:latest

自定义docker0桥的网络属性信息：/etc/docker/daemon.json文件
{
	"bip": "192.168.1.5/24"
	"fixed-cidr": "10.20.0.0/16",
	"fixed-cidr-v6": "2001:db8::/64",
	"mtu": 1500,
	"default-gateway": "10.20.1.1",
	"default-gateway-v6": "2001:db8:abcd::89",
	"dns": ["10.20.1.2","10.20.1.3"]
}
核心选项为bip，即bridge ip之意，用于指定docker0桥自身IP地址；其他选项可通过此地址计算得出。

dockerd守护进程的C/S，其默认仅监听Unix socket格式的地址，/var/run/docker.sock；如果使用TCP套接字，
/etc/docker/daemon.json:
	"hosts": ["tcp://0.0.0.0:2375", "unix:///var/run/docker.sock"]
也可向dockerd直接传递"-H|--host"选项；

修改192.168.23.113节点上/etc/docker/daemon.json
{
  "registry-mirrors": ["https://tx5kz423.mirror.aliyuncs.com"],
  "bip": "10.0.0.1/16",
  "hosts": ["tcp://0.0.0.0:2375", "unix:///var/run/docker.sock"]
}
systemctl restart docker.service
ss -tnl

修改了daemon.json，docker.service无法启动：
centos中找到/usr/lib/systemd/system/docker.service,
将其中的ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock
  修改成ExecStart=/usr/bin/dockerd

在192.168.23.111节点上：
docker -H 192.168.23.112:2375 container ps -a

创建新的桥：
docker network ls
docker network create -d bridge --subnet "172.26.0.0/16" --gateway "172.26.0.1" docker1		

docker network create -d bridge \
  --subnet "172.18.0.0/16"  \
  --gateway "172.18.0.1" \
  -o "com.docker.network.bridge.name"="docker1" \
  bridge2

[root@docker02☻ /etc/docker]# docker network create -d bridge --subnet "172.26.0.0/16" --gateway "172.26.0.1" mybridge
9c72f334e7f416611c4721919614c8b8469b8c7f0be227affbd9ba1b102e245f
[root@docker02☻ /etc/docker]# docker network ls
NETWORK ID          NAME                DRIVER              SCOPE
31a23b0d3f42        bridge              bridge              local
2cb0f7254aa7        host                host                local
9c72f334e7f4        mybridge            bridge              local
fef0a2bc39f1        none                null                local
[root@docker02☻ /etc/docker]# ifconfig
br-9c72f334e7f4: flags=4099<UP,BROADCAST,MULTICAST>  mtu 1500
        inet 172.26.0.1  netmask 255.255.0.0  broadcast 172.26.255.255
        ether 02:42:6d:95:1c:7e  txqueuelen 0  (Ethernet)
        RX packets 0  bytes 0 (0.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 (0.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

docker0: flags=4099<UP,BROADCAST,MULTICAST>  mtu 1500
        inet 10.0.0.1  netmask 255.255.0.0  broadcast 10.0.255.255
        ether 02:42:9a:8f:5e:ba  txqueuelen 0  (Ethernet)
        RX packets 0  bytes 0 (0.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 (0.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

ens32: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 192.168.23.112  netmask 255.255.255.0  broadcast 192.168.23.255
        inet6 fe80::24b8:6e2c:8bdb:fdb6  prefixlen 64  scopeid 0x20<link>
        inet6 fe80::ed30:5392:a000:f088  prefixlen 64  scopeid 0x20<link>
        ether 00:0c:29:1b:48:21  txqueuelen 1000  (Ethernet)
        RX packets 11806  bytes 877429 (856.8 KiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 5973  bytes 827032 (807.6 KiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

lo: flags=73<UP,LOOPBACK,RUNNING>  mtu 65536
        inet 127.0.0.1  netmask 255.0.0.0
        inet6 ::1  prefixlen 128  scopeid 0x10<host>
        loop  txqueuelen 1000  (Local Loopback)
        RX packets 2  bytes 168 (168.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 2  bytes 168 (168.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

[root@docker02☻ /etc/docker]#
[root@docker02☻ /etc/docker]# ip link set dev br-9c72f334e7f4 name docker1
RTNETLINK answers: Device or resource busy
[root@docker02☻ /etc/docker]# ifdown br-9c72f334e7f4
usage: ifdown <configuration>
[root@docker02☻ /etc/docker]# ifdown "br-9c72f334e7f4"
usage: ifdown <configuration>
[root@docker02☻ /etc/docker]# ifconfig br-9c72f334e7f4 down
[root@docker02☻ /etc/docker]# ip link set dev br-9c72f334e7f4 name docker1
[root@docker02☻ /etc/docker]#
[root@docker02☻ /etc/docker]#
[root@docker02☻ /etc/docker]#
[root@docker02☻ /etc/docker]# ifconfig docker1 up
[root@docker02☻ /etc/docker]# ifconfig
docker0: flags=4099<UP,BROADCAST,MULTICAST>  mtu 1500
        inet 10.0.0.1  netmask 255.255.0.0  broadcast 10.0.255.255
        ether 02:42:9a:8f:5e:ba  txqueuelen 0  (Ethernet)
        RX packets 0  bytes 0 (0.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 (0.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

docker1: flags=4099<UP,BROADCAST,MULTICAST>  mtu 1500
        inet 172.26.0.1  netmask 255.255.0.0  broadcast 172.26.255.255
        ether 02:42:6d:95:1c:7e  txqueuelen 0  (Ethernet)
        RX packets 0  bytes 0 (0.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 (0.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0  
ens32: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 192.168.23.112  netmask 255.255.255.0  broadcast 192.168.23.255
        inet6 fe80::24b8:6e2c:8bdb:fdb6  prefixlen 64  scopeid 0x20<link>
        inet6 fe80::ed30:5392:a000:f088  prefixlen 64  scopeid 0x20<link>
        ether 00:0c:29:1b:48:21  txqueuelen 1000  (Ethernet)
        RX packets 12177  bytes 905887 (884.6 KiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 6258  bytes 862308 (842.0 KiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

lo: flags=73<UP,LOOPBACK,RUNNING>  mtu 65536
        inet 127.0.0.1  netmask 255.0.0.0
        inet6 ::1  prefixlen 128  scopeid 0x10<host>
        loop  txqueuelen 1000  (Local Loopback)
        RX packets 2  bytes 168 (168.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 2  bytes 168 (168.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

[root@docker02☻ /etc/docker]#

创建容器b1加入新创建的mybridge，网段是172.26.0.0
docker container run --name b1 -it --rm --network mybridge busybox:latest

创建容器b2加入原来的bridge，网段是10.0.0.0
docker container run --name b2 -it --rm --network bridge busybox:latest

查看内核的包转发是否打开
[root@docker02☻ /etc/docker]# cat /proc/sys/net/ipv4/ip_forward
1
[root@docker02☻ /etc/docker]#

[root@docker02☻ ~]# docker container run --name b1 -it --rm --network mybridge busybox:latest
docker: Error response from daemon: failed to create endpoint b1 on network mybridge: adding interface veth1d2cf65 to bridge br-9c72f334e7f4 failed: could not find bridge br-9c72f334e7f4: route ip+net: no such network interface.
ERRO[0000] error waiting for container: context canceled

===============================================================================
===============================================================================
===============================================================================
06-Docker存储卷
COW（写时复制）
？如何确认一个文件是镜像的那一层

容器保存数据到容器外的存储空间叫"存储卷"：volume
使用volume可以让数据和容器分离

任何有状态的应用都应该持久保存数据；
docker存储卷默认就是本地宿主机的一个目录；

Volume types
	Bind mount volume
		docker container run -it --name b1 -v hostdir:volumedir busybox:latest
		docker container inspect -f {{.Mounts}} b1
	Docker-managed volume
		docker container run -it --name b2 -v volumedir busybox:latest
		docker container inspect -f {{.Mounts}} b2

docker container run -it --name b1 -h b1 --rm -v /data busybox:latest
docker container run -it --name b1 -h b1 --rm -v /container/busybox-b1:/data busybox:latest

go模板
[]：列表
{}：哈希、映射、关联数组，josn数组 

docker container inspect -f {{.NetworkSettings.IPAddress}} b1

两个容器共享同一个存储卷
docker container run -it --name b1 -h b1 --rm -v /container/busybox-b12:/data busybox:latest
docker container run -it --name b2 -h b2 --rm -v /container/busybox-b12:/data busybox:latest

启动一个容器，这个容器复制使用一个已存在的容器的存储卷
docker container run -it --name b3 -h b3 --rm --volumes-from b2 busybox:latest

创建一个底层基础支撑容器infracon，提供网络和存储；
docker container run --name infracon -h infracon -it -v /container/busybox-infracon/:/data/web/html busybox:latest 
docker container run --name nginx -h nginx --network container:infracon --volumes-from infracon -it --rm busybox

docker-compose：docker的单机容器编排工具


===============================================================================
===============================================================================
===============================================================================
07-Dockerfile详解
？启动（run）容器并挂载存储卷（宿主机上的一个目录），那个先、那个后，可否把容器上应用的配置文件放在存储卷上？

nginx
	nginx
	docker exec CONTAINER vi , reload
	自制镜像：
		基于容器

server.conf, /etc/nginx/conf.d/
{
	server_name $NGX_SERVER_NAME;
	listen $NGINX_PROT;
	root $DOC_ROOT;
}
一个容器，多个配置文件
变量替换：在容器内部主进程启动前先启动一个临时进程，将用户传递进来的参数替换到容器配置文件中去（/etc/nginx/config.d/），在使用exec启动主进程替换自己。云原生做到了不使用配置文件，直接通过环境变量传递参数。

Dockerfile Format
Format
	#Comment
	INSTRUCTION arguments
The instruction is not case-sensitive
	However, convention is for them to be UPPERCASE to distinguish them from arguments more easily
Docker runs instructions in a Dockerfile in order
The first instuction must be 'FROM' in order to specify the Base Image from which you are building

dockerfile
在专用目录下做；
新imgae的所有"文件/目录"都要放在这个目录下；
.dockeringore文件包含了不放入image的类表，可使用通配符；
可使用环境变量；
	$variable_name or ${variable_name}
	${variable:-word}：如果variable没有定义，或者variable为空，则variable为word；
	${variable:+word}：如果variable有定义，则variable为word；
docker build
	隐藏的启动一个容器，用来执行shell命令。
？这个隐藏启动的容器是基于那个image呢？

dockerfile具体指令
FORM
	FORM <repository>[:<tag>]
	FORM <resository>@<digest>
MAINTANIER (depreacted)
	MAINTAINER  "congjun <CJo_126@126.com>"
LABLE (adds metadata to an image)
	LABEL <key>=<value> <key>=<value> <key>=<value> ...
COPY
	COPY <src>... <dest>
	COPY ["<scr>",... "<dest>"]

docker image build -t cjohttpd:v0.1 ./
[root@docker01 ~/img1]# docker image build -t cjohttpd:v0.1 ./
Sending build context to Docker daemon  3.072kB
Step 1/3 : FROM busybox:latest
 ---> 018c9d7b792b
Step 2/3 : MAINTAINER "congjun <CJo_126@126.com>"
 ---> Running in 5195657ee2ae
Removing intermediate container 5195657ee2ae
 ---> 6ec9e6ea2a7a
Step 3/3 : COPY index.html /data/web/html/
 ---> 7b94f073b8fe
Successfully built 7b94f073b8fe
Successfully tagged cjohttpd:v0.1
[root@docker01 ~/img1]#

docker container run -it --name ch1 -h ch1 --rm cjohttpd:v0.1
docker container run --name ch1 -h ch1 --rm cjohttpd:v0.1 cat /data/web/html/index.html

ADD （类似COPY指令，ADD支持使用TAR文件和URL路径）
	ADD <src>... <dest>
	ADD ["<scr>",... "<dest>"]
	支持本地tar文件的自动展开，url的tar文件不会自动展开
ADD http://nginx.org/download/nginx-1.18.0.tar.gz /usr/local/src/

WORKDIR （指定工作目录，可多次使用）
	WORKDIR /usr/local/src/
	ADD nginx-1.18.0.tar.gz ./

	WORKDIR /usr/local/
	ADD nginx-1.18.0.tar.gz ./src/

VOLUME (可以挂载docker hosts上的卷或其他容器的卷)
	VOLUME <mountpoint>
	VOLUME ["<mountpoint>"]
VOLUME /data/mysql/

EXPOSE （为容器打开指定要监听的端口以实现与外部通信）
	EXPOSE <port>[/<protocal>] [<port>[/<protocal>] ...]
	EXPOSE 11211/udp 11211/tcp
注：该指令只是让容器具备打开端口的能力，如果容器需要真暴露，需要在启动容器时添加 -P 参数

docker container run --name ch6 -h ch6 --rm cjohttpd:v0.6 httpd -f -h /data/web/html/
[root@docker01 ~]# curl 172.17.0.2
<h1>Busybox httpd server.</h1>
<h1>I need power!!!</h1>
[root@docker01 ~]#
[root@docker01 ~]# docker port ch6
[root@docker01 ~]#
[root@docker01 ~/img1]# docker container run --name ch6 -h ch6 --rm -P cjohttpd:v0.6 httpd -f -h /data/web/html/
[root@docker01 ~]# docker port ch6
80/tcp -> 0.0.0.0:4000
[root@docker01 ~]#
[root@docker01 ~]# curl 127.0.0.1:4000
<h1>Busybox httpd server.</h1>
<h1>I need power!!!</h1>
[root@docker01 ~]#

ENV （用于为image定义所需的环境变量，并可被Dockerfile文件中位于其后的其它指令所调用）
	ENV <key><value>
	ENV <key>=<value> <key>=<value> ...
	调用格式：$variable_name 或 ${variable_name}
	如果变量值中有空格，可以用 \ 转义，在dockerfile中定义的环境变量用于在build image时使用。image构建好后会保存在image中。

创建容器（docker container run）时可以指定环境变量（-e），如果image中已存在这个环境变量就修改其值，如果image中没有就新建。

[root@docker01 ~/img1]# docker container run --name ch7 -h ch7 --rm -P cjohttpd:v0.7 printenv
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
HOSTNAME=ch7
DOC_ROOT=/data/web/html/
WEB_SERVER_PACKAGE=nginx-1.18.0
HOME=/root

RUN （image在build过程中执行的命令，命令必须在FROM指定的image中包含）
	RUN <command>  # shell命令，且以 "/bin/sh -c" 来运行，意味着此进程在容器中PID不为1，不能接收Unix信号，因此当使用docker container sotp 命令停止容器时，此进程接收不到SIGTERM信号；
	RUN ["<executable>","<param1>","<param2>"]  # json数组，不以 "/bin/sh -c" 来发起。
	RUN ["/bin/bash", "-c","<executable>","<param1>","<param2>"]  # json数组，以 "/bin/sh -c" 来发起。
	RUN  CMD1 && \
	     CMD2 && \
		 CMD3 && \
		 ....
		 CMDn

FROM centos
RUN yum -y install epel-release &&\
    yum makecache && \
	yum -y install nginx &&\
	yum clean all


===============================================================================
===============================================================================
===============================================================================
08-Dockerfile详解
img2
CMD、RUN、ENTRYPOINT的区别

================img2 Dockerfile================/*{{{*/
FROM busybox:latest
LABEL maintainer="CongJun <CJo_126@126.com>" app="httpd"

ENV WEB_DOC_ROOT="/data/web/html/"

RUN mkdir -p $WEB_DOC_ROOT &&\
    echo '<h1>Busybox httpd server.' > ${WEB_DOC_ROOT}/index.html

# CMD /bin/httpd -f -h ${WEB_DOC_ROOT}
# CMD ["/bin/httpd","-f","-h ${WEB_DOC_ROOT}"]
# CMD ["/bin/sh","-c","/bin/httpd","-f","-h ${WEB_DOC_ROOT}"]
# ENTRYPOINT /bin/httpd -f -h ${WEB_DOC_ROOT}
CMD ["/bin/httpd","-f","-h /data/web/html"]
ENTRYPOINT /bin/sh -c
================img2 Dockerfile================/*}}}*/



CMD （容器启动时运行的命令，该命令如果运行结束，容器也将终止；CMD指定的命令可以被docker container run命令覆盖）
	CMD <command>
	CMD ["<executable>","<param1>","<param2>"...]
	CMD ["<param1>","<param2>"...]
	前两种等同于RUN，第三种用于为ENTRYPOINT指令提供默认参数；
	在Dockerfile中可以有多条CMD语句（语法不会报错），但只有最后一条生效。

CMD /bin/httpd -f -h ${WEB_DOC_ROOT}
[root@docker01☻ ~/img2]# docker container run --name ah1 -h ah1 --rm -it alitahttpd:v0.1-1
启动容器后无交互界面
[root@docker01☻ ~]# docker image inspect alitahttpd:v0.1-1
	"Cmd": [
	    "/bin/sh",
	    "-c",
	    "#(nop) ",
	    "CMD [\"/bin/sh\" \"-c\" \"/bin/httpd -f -h ${WEB_DOC_ROOT}\"]"
	],
[root@docker01☻ ~]# docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES
56efaf9040bb        alitahttpd:v0.1-1   "/bin/sh -c '/bin/ht…"   20 seconds ago      Up 19 seconds                           ah1
[root@docker01☻ ~]#
[root@docker01☻ ~]# docker container exec -it ah1 /bin/sh
/ # ps
PID   USER     TIME  COMMAND
    1 root      0:00 /bin/httpd -f -h /data/web/html/
    7 root      0:00 /bin/sh
   12 root      0:00 ps
/ # 
通过CMD的这种方式运行的命令pid为1，
image的默认运行命令；
该命令是通过shell启动的；
执行了exec的替换操作，所以该进程的pid为1，确保这个容器可以接收unix信号；
该命令可以接收docker container stop 等命令。



CMD ["/bin/httpd","-f","-h ${WEB_DOC_ROOT}"]
这种模式，命令是json参数，命令不是以shell启动，所以环境变量无法使用
[root@docker01☻ ~/img2]# cat Dockerfile
FROM busybox:latest
LABEL maintainer="CongJun <CJo_126@126.com>" app="httpd"
ENV WEB_DOC_ROOT="/data/web/html/"
RUN mkdir -p $WEB_DOC_ROOT &&\
    echo '<h1>Busybox httpd server.' > ${WEB_DOC_ROOT}/index.html
# CMD /bin/httpd -f -h ${WEB_DOC_ROOT}
CMD ["/bin/httpd","-f","-h ${WEB_DOC_ROOT}"]

[root@docker01☻ ~/img2]# docker image build -t alitahttpd:v0.1-2 ./

[root@docker01☻ ~/img2]# docker image inspect alitahttpd:v0.1-2
	"Cmd": [
	    "/bin/httpd",
	    "-f",
	    "-h ${WEB_DOC_ROOT}"
	],

[root@docker01☻ ~/img2]# docker container run -it --name ah2 -h ah2 --rm alitahttpd:v0.1-2
httpd: can't change directory to ' ${WEB_DOC_ROOT}': No such file or directory
[root@docker01☻ ~/img2]#
[root@docker01☻ ~/img2]# docker container run -it --name ah2 -h ah2 --rm alitahttpd:v0.1-2 /bin/sh
/ #
/ # printenv
WEB_DOC_ROOT=/data/web/html/
HOSTNAME=ah2
SHLVL=1
HOME=/root
TERM=xterm
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
PWD=/
~ # ls /data/web/html/index.html
/data/web/html/index.html
~ # cat /data/web/html/index.html
<h1>Busybox httpd server.
~ #

CMD ["/bin/httpd","-f","-h ${WEB_DOC_ROOT}"]
变为：
CMD ["/bin/sh","-c","/bin/httpd","-f","-h ${WEB_DOC_ROOT}"]


ENTRYPOINT
	类似CMD指令功能，用于为容器指定默认运行程序，从而使得容器像是一个单独可执行程序；
	与CMD不同的是，由ENTRYPOINT启动的程序不会被docker container run命令行指定的参数覆盖；
	docker container run 的--entrypoint参数可覆盖ENTRYPOINT指令指定的程序；
	docker container run命令传入的命令参数会覆盖CMD指令的内容并且附加到ENTRYPOINT命令最后作为起参数；
	Dockerfile可以有多个ENTRYPOINT指令（无语法错误），但只有最后一个会生效；
	ENTRYPOINT <command>  # 用shell执行
	ENTRYPOINT ["<executable>","<param1>","<param2>"]  # 不用shell执行
	如果要强制覆盖可以使用 docker container run 的--entrypoint参数；
docker container run -it --name ah4 -h ah4 --rm --entrypoint "/bin/sh" alitahttpd:v0.1-4

如果CMD和ENTRYPOINT同时定义，则CMD作为默认参数传递给ENTRYPOINT，默认参数指ENTRYPOINT没有参数时起作用，如果ENTRYPOINT有参数则不起作用；
Dockerfile文件中如下定义：
CMD ["/bin/httpd","-f","-h /data/web/html"]
ENTRYPOINT /bin/sh -c
生成image alitahttpd:v0.1-6
docker container run -it --name ah6 -h ah6 --rm alitahttpd:v0.1-6
上面方式启动容器，ENTRYPOINT 没有参数，CMD 定义的参数（"/bin/httpd","-f","-h /data/web/html"）起作用；
docker container run -it --name ah6 -h ah6 --rm alitahttpd:v0.1-6 "ls -l /etc" 
上面方式启动容器，ENTRYPOINT 有参数"ls -l /etc"，CMD 定义的参数不起作用；
？可以这样理解吗？docker container run 传递的参数可以覆盖CMD指定的命令；

container传递参数一般靠环境变量；
通过ENTRYPOINT命令，可以只定义为 /bin/sh ，通过 CMD 命令或 dockers container run  来传递参数；


img3
通过docker container run 给nginx传递参数

Dockerfile文件中有CMD和ENTRYPOINT指令，CMD指令作为ENTRYPOINT指令的参数，所以ENTRYPOINT指令为：
/bin/entrypoint.sh  /usr/sbin/nginx -g daemon off;
entrypoint.sh先创建nginx的配置文件；
然后执行：exec "$@"，即/usr/sbin/nginx -g daemon off，并替换PID为1;

================img3 Dockerfile================/*{{{*/
FROM nginx:1.14-alpine
LABEL maintainer="CongJun <CJo_126@126.com>"

ENV NGX_DOC_ROOT='/data/web/html/'

ADD index.html ${NGX_DOC_ROOT}
ADD entrypoint.sh /bin/

CMD ["/usr/sbin/nginx","-g","daemon off;"]

ENTRYPOINT ["/bin/entrypoint.sh"]
================img3 Dockerfile================/*}}}*/

================img3 entrypoint.sh================/*{{{*/
#!/bin/sh
#
cat > /etc/nginx/conf.d/www.conf <<EOF
server {
	server_name $HOSTNAME;
	listen ${IP:-0.0.0.0}:${PORT:-80};
	root ${NGX_DOC_ROOT:-/usr/share/nginx/html};
}
EOF

exec "$@"
================img3 entrypoint.sh================/*}}}*/
chmod +x entrypoint.sh

$@：脚本的所有参数；
exec "$@"：执行并替换进程，使运行的进程pid为1；

================img3 index.html================/*{{{*/
<h1>Give me strength!!</h1>
<h1>Give me wisdom!!</h1>
================img3 index.html================/*}}}*/

docker container run -it --name 

docker container run -it --name web1 -h web1  -e "IP=172.17.0.2" -e "PORT=8080" ngxweb:v0.1-1

json数组中要使用双引号


================img4================/*{{{*/
容器的配置文件：
[root@docker01☻ ~/img4]# cat Dockerfile
FROM nginx:1.14-alpine
LABEL maintainer="CongJun <CJo_126@126.com>"
ENV NGX_DOC_ROOT='/data/web/html/'
ADD index.html ${NGX_DOC_ROOT}
ADD entrypoint.sh /bin/
CMD ["/bin/entrypoint.sh"]

[root@docker01☻ ~/img4]#
[root@docker01☻ ~/img4]# cat entrypoint.sh
#!/bin/sh
#
cat > /etc/nginx/conf.d/www.conf <<EOF
server {
        server_name $HOSTNAME;
        listen ${IP:-0.0.0.0}:${PORT:-80};
        root ${NGX_DOC_ROOT:-/usr/share/nginx/html};
}
EOF
/usr/sbin/nginx -g 'daemon off;'

[root@docker01☻ ~/img4]#

创建容器：
[root@docker01☻ ~/img4]# dockdocker image build -t ngx:v0.1-4 ./

启动容器并传递参数
[root@docker01☻ ~/img4]# docker container run --name web1 -h web1 --rm -e "IP=172.17.0.2" -e "PORT=8080" ngx:v0.1-4

[root@docker01☻ ~/img4]# docker container exec -it web1 /bin/sh
/ # ls
bin    data   dev    etc    home   lib    media  mnt    opt    proc   root   run    sbin   srv    sys    tmp    usr    var
/ # cat /data/web/html/index.html   
<h1>Give me strength!!</h1>         
<h1>Give me wisdom!!</h1>           
/ #                                 
/ # printenv
HOSTNAME=web1
SHLVL=1
PORT=8080
HOME=/root
TERM=xterm
NGINX_VERSION=1.14.2
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
NGX_DOC_ROOT=/data/web/html/
PWD=/
IP=172.17.0.2
/ # cd /etc/nginx/conf.d/
/etc/nginx/conf.d # ls
default.conf  www.conf
/etc/nginx/conf.d # cat www.conf
server {
        server_name web1;
        listen 172.17.0.2:8080;
        root /data/web/html/;
}
/etc/nginx/conf.d # netstat -tlnup
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name
tcp        0      0 172.17.0.2:8080         0.0.0.0:*               LISTEN      8/nginx -g daemon o
tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      8/nginx -g daemon o
/etc/nginx/conf.d #
/etc/nginx/conf.d # wget -O - -q localhost
<!DOCTYPE html>
<html>
<head>
<title>Welcome to nginx!</title>
<style>
    body {
        width: 35em;
        margin: 0 auto;
        font-family: Tahoma, Verdana, Arial, sans-serif;
    }
</style>
</head>
<body>
<h1>Welcome to nginx!</h1>
<p>If you see this page, the nginx web server is successfully installed and
working. Further configuration is required.</p>

<p>For online documentation and support please refer to
<a href="http://nginx.org/">nginx.org</a>.<br/>
Commercial support is available at
<a href="http://nginx.com/">nginx.com</a>.</p>

<p><em>Thank you for using nginx.</em></p>
</body>
</html>
/etc/nginx/conf.d #
/etc/nginx/conf.d # wget -O - -q http://172.17.0.2:8080
<h1>Give me strength!!</h1>
<h1>Give me wisdom!!</h1>

/etc/nginx/conf.d #
/etc/nginx/conf.d # wget -O - -q http://0 0.0.0.0:80                                  
<!DOCTYPE html>                                                                       
<html>                                                                                
<head>                                                                                
<title>Welcome to nginx!</title>                                                      
<style>                                                                               
    body {                                                                            
        width: 35em;                                                                  
        margin: 0 auto;                                                               
        font-family: Tahoma, Verdana, Arial, sans-serif;                              
    }                                                                                 
</style>                                                                              
</head>                                                                               
<body>                                                                                
<h1>Welcome to nginx!</h1>                                                            
<p>If you see this page, the nginx web server is successfully installed and           
working. Further configuration is required.</p>                                       
                                                                                      
<p>For online documentation and support please refer to                               
<a href="http://nginx.org/">nginx.org</a>.<br/>                                       
Commercial support is available at                                                    
<a href="http://nginx.com/">nginx.com</a>.</p>                                        
                                                                                      
<p><em>Thank you for using nginx.</em></p>                                            
</body>                                                                               
</html>                                                                               
<!DOCTYPE html>                                                                       
<html>                                                                                
<head>                                                                                
<title>Welcome to nginx!</title>                                                      
<style>                                                                               
    body {                                                                            
        width: 35em;                                                                  
        margin: 0 auto;                                                               
        font-family: Tahoma, Verdana, Arial, sans-serif;                              
    }                                                                                 
</style>                                                                              
</head>                                                                               
<body>                                                                                
<h1>Welcome to nginx!</h1>                                                            
<p>If you see this page, the nginx web server is successfully installed and           
working. Further configuration is required.</p>                                       
                                                                                      
<p>For online documentation and support please refer to                               
<a href="http://nginx.org/">nginx.org</a>.<br/>                                       
Commercial support is available at                                                    
<a href="http://nginx.com/">nginx.com</a>.</p>                                        
                                                                                      
<p><em>Thank you for using nginx.</em></p>                                            
</body>                                                                               
</html>                                                                               
/etc/nginx/conf.d #                                                                   
/etc/nginx/conf.d # ps
PID   USER     TIME  COMMAND
    1 root      0:00 {entrypoint.sh} /bin/sh /bin/entrypoint.sh
    8 root      0:00 nginx: master process /usr/sbin/nginx -g daemon off;
    9 nginx     0:00 nginx: worker process
   10 root      0:00 /bin/sh
   23 root      0:00 ps
================img4================/*}}}*/


================img5================/*{{{*/
配置文件:
[root@docker01☻ ~/img5]# cat Dockerfile
FROM nginx:1.14-alpine
LABEL maintainer="CongJun <CJo_126@126.com>"
ENV NGX_DOC_ROOT='/data/web/html/'
ADD index.html ${NGX_DOC_ROOT}
ADD entrypoint.sh /bin/
CMD ["/bin/entrypoint.sh"]

[root@docker01☻ ~/img5]# cat entrypoint.sh
#!/bin/sh
#
cat > /etc/nginx/conf.d/www.conf <<EOF
server {
        server_name $HOSTNAME;
        listen ${IP:-0.0.0.0}:${PORT:-80};
        root ${NGX_DOC_ROOT:-/usr/share/nginx/html};
}
EOF

#exec "$@"
exec /usr/sbin/nginx -g 'daemon off;'

创建容器：
[root@docker01☻ ~/img5]# docker contimage build -t ngx:v0.1-5 ./

运行容器
[root@docker01☻ ~/img5]# docker container run --name web1 -h web1 --rm -e "IP=172.17.0.2" -e "PORT=8080" ngx:v0.1-5
172.17.0.2 - - [01/Sep/2020:09:51:04 +0000] "GET / HTTP/1.1" 200 55 "-" "Wget" "-"

验证:
[root@docker01☻ ~/img5]# docker container exec -it web1 /bin/sh                                    
/ # ps                                                                                             
PID   USER     TIME  COMMAND                                                                       
    1 root      0:00 nginx: master process /usr/sbin/nginx -g daemon off;                          
    8 nginx     0:00 nginx: worker process                                                         
   18 root      0:00 /bin/sh                                                                       
   23 root      0:00 ps                                                                            
/ # printenv                                                                                       
HOSTNAME=web1                                                                                      
SHLVL=1                                                                                            
PORT=8080                                                                                          
HOME=/root                                                                                         
TERM=xterm                                                                                         
NGINX_VERSION=1.14.2                                                                               
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin                                  
NGX_DOC_ROOT=/data/web/html/                                                                       
PWD=/                                                                                              
IP=172.17.0.2                                                                                      
/ # netstat -tlnup                                                                                 
Active Internet connections (only servers)                                                         
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name   
tcp        0      0 172.17.0.2:8080         0.0.0.0:*               LISTEN      1/nginx -g daemon o
tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      1/nginx -g daemon o
/ # cat /etc/nginx/conf.d/www.conf                                                                 
server {                                                                                           
        server_name web1;                                                                          
        listen 172.17.0.2:8080;                                                                    
        root /data/web/html/;                                                                      
}                                                                                                  
/ #                                                                                                
/ # cat /data/web/html/index.html                                                                  
<h1>Give me strength!!</h1>                                                                        
<h1>Give me wisdom!!</h1>                                                                          
                                                                                                   
/ #                                                                                                
/ # wget -O - -q http://172.17.0.2:8080                                                            
<h1>Give me strength!!</h1>                                                                        
<h1>Give me wisdom!!</h1>                                                                          
                                                                                                   
/ #                                                                                                
================img5================/*}}}*/

容器中运行主程序的用户应该是一个普通用户，不要使用root用户：
[root@docker01☻ ~/img5]# docker container exec -it web1 /bin/sh                                    
/ # ps                                                                                             
PID   USER     TIME  COMMAND                                                                       
    1 root      0:00 nginx: master process /usr/sbin/nginx -g daemon off;                          
    8 nginx     0:00 nginx: worker process                                                         
   18 root      0:00 /bin/sh                                                                       
   23 root      0:00 ps                                                                            
下面这条命令不要用root用户执行；
nginx: master process /usr/sbin/nginx -g daemon off;                          

指定的用户必须存在（没有执行成功，yum命令不存在）
[root@docker01 ~/img5]# cat Dockerfile
FROM nginx:1.14-alpine
LABEL maintainer="CongJun <CJo_126@126.com>"
RUN yum -y install shadow-utils && \
    yum clean all && \
    groupadd web01 && \
    useradd -g web01 web01 && \
    echo "passw0rd" | passwd --stdin web01 &&\
    mkdir -p $NGX_DOC_ROOT &&\
    chown -R web01:web01 $NGX_DOC_ROOT

ENV NGX_DOC_ROOT='/data/web/html/'
ADD index.html ${NGX_DOC_ROOT}
ADD entrypoint.sh /bin/
USER web01
CMD ["/bin/entrypoint.sh"]

================img3 h================
================img3 h================

docker容器是否正常运行？
1、主进程正常运行；
2、主进程所需文件正常；
k
===============================================================================
===============================================================================
===============================================================================
09-Docker私有registry
Go
docker-distribution：创建私有registry的包（项目）
可运行在容器中

在extras仓库docker-registry的软件包
python开发的自运行的web服务程序
yum install docker-registry
rpm -ql docker-distribution
/usr/lib/systemd/system/docker-distribution.service

[cj@docker01☻ /usr/lib/systemd/system]$ more docker-distribution.service
[Unit]
Description=v2 Registry server for Docker
After=network.target

[Service]
Type=simple
ExecStart=/usr/bin/registry serve /etc/docker-distribution/registry/config.yml
Restart=on-failure

[Install]
WantedBy=multi-user.target
[cj@docker01☻ /usr/lib/systemd/system]$ more /etc/docker-distribution/registry/config.yml
version: 0.1
log:
  fields:
    service: registry
storage:
    cache:
        layerinfo: inmemory
    filesystem:
        rootdirectory: /var/lib/registry  ##image保存位置
http:
    addr: :5000  ##没写地址，表示所有地址，端口是5000
[cj@docker01☻ /usr/lib/systemd/system]$

systemctl start docker-distribution
ss -tnl
netstat -tlnup
docker tag ngx:v0.1-5 docker01:5000/ngx:v0.1-5
docker push  docker01:5000/ngx:v0.1-5
[root@docker01☻ ~]# docker push  docker01:5000/ngx:v0.1-5
The push refers to repository [docker01:5000/ngx]
Get https://docker01:5000/v2/: http: server gave HTTP response to HTTPS client

使用http协议传输
vim /etc/docker/daemon.json
	"insecure-registries":["docker01:5000"]
sysemctl restart docker.service

[cj@docker01☻ /etc/docker]$ cat daemon.json                    
{                                                              
  "registry-mirrors": ["https://tx5kz423.mirror.aliyuncs.com"],
  "insecure-registries":["docker01:5000"]                      
}                                                              


[root@docker01☻ /etc/docker]# docker push  docker01:5000/ngx:v0.1-5
The push refers to repository [docker01:5000/ngx]
3011a9c57480: Pushed
b0c1f3f09768: Pushed
076c58d2644f: Pushed
b2cbae4b8c15: Pushed
5ac9a5170bf2: Pushed
a464c54f93a9: Pushed
v0.1-5: digest: sha256:37d7719c907a64f69e5e405fb7ebbd0697bc335460c71c10dd3ce978a78dcd49 size: 1567
[root@docker01☻ /etc/docker]#


如果要拉取自建仓库的image，需要和服务器配置相同，主要是否使用http协议；

CNFC，harbor，私有仓库项目，vmware团队
harbor安装难，需要docker的单机编排工具compose
compose各版本语法不同
yum info docker-compose
docker-compose读取compose文件，类似于docker image build读取Dockerfile文件。
https://github.com/goharbor/harbor 
安装文档：https://goharbor.io/docs/2.0.0/install-config/

tar xf harbor-offline-installer-vxxx.tgz -C /usr/local/
cd /usr/local/harbor/
vim docker-compose.yml
	image存放位置
vim harbor.cfg
hostname = node02.magedu.com
ui_url_protocol = http
max_job_workers = 略小于cpu核心数
customize_crt = 是否使用自定义的证书，ui_url_protocol = https才可以
harbor_admin_password = 口令

yum -y install docker-compose
./install.sh
安装完成后查看端口
ss -tnl
80,443,4443
ss -tnlp
harbor启动容器会共享物理机的端口
http://192.168.23.111

客户端在推送image前需要：
修改daemon.json，端口
登录
docker login node02.magedu.com
给要推送的image打标
docker tag  image:tag node02.magedu.com/devel/myweb

执行命令必须要在/usr/local/harbor目录下，这些命令依赖docker-compose.yml
停止compose服务：
在docker-compose.yml文件目录下执行
docker-compose pause
docker-compose unpause
docker-compose stop
docker-compose start

===============================================================================
===============================================================================
===============================================================================
10-Docker的系统资源限制及验正
默认，docker没有资源限制；
memory，cpu，block IO
docker资源限制基于内核的Linux capabilities实现
OOME：Out Of Memory Exception
一旦发生OOME，任何进程都有可能被kill，包括docker daemon，为此，Docker特地调整了docker daemon的OOM优先级。容器的优先级并未被调整。
hogs，谁最占内存
oom_score值最高的先被kill
oom_adj是权重，越低越重要，不容易被kill。

内存限制：
-m Or --memory= 
限制RAM大小

--memory-swap *
必须先设置-m，才能使用这个参数，限制swap
--memory-swap		--memory
+S					+M			swap=S-M
0					+M			unset swap
unset				+M			Docker host启用了swap，则swap=2*M
-1					+M			Docker host启用了swap，则swap=Docker host的所有swap
注意：在容器内使用free命令可以看到的swap空间并不是容器实际的实际swap

--memory-swappiness
容器swap使用的倾向性，0不使用，100

--memory-reserviation
预留的内存空间

--oom-kill-disable
Docker host发生了oom，如果设置未true，不被kill

CPU
linux系统优先级默认120（100-139，-20-19，越低优先级越高）
非实时优先级：100-139，-20-19
实时优先级：0-99，内核用
CFS scheduler
CPU密集型
IO密集型

--cpus=  最多使用几核。
--cpuset-cpus  这个容器只能运行在指定的cpu内核上。
--cpu-shares  按比例切分所有cpu
--cpu-period=  限制使用时间


lscpu

dockerhub
	stress   压测
docker pull lorel/docker-stress-ng

memory
docker container run -it --rm --name st1 lorel/docker-stress-ng --help
docker container run -it --rm --name st1 -m 256m lorel/docker-stress-ng --vm 2 
docker container top st1
docker container stats

cpu
docker container run -it --rm --name st1 --cpus 2 lorel/docker-stress-ng --cpu 4 
docker container top st1
docker container stats



================Quesion================
1、如何在Docker中创建一个用户？
	安装useradd命令
	修改/etc/passwd和/etc/group 等文件
2、如何在构建image时修改一个已存在文件的内容？
	修改内容
	添加/删除 内容
3、https和http效率有区别吗？

4、如何查看一个容器历史资源使用情况（资源没限制）？
================Quesion================

yum install -y yum-utils
#查询一个未安装的包中有哪些文件
repoquery -ql  package-name 
repoquery -qlis  package-name 
repoquery -ql --location package-name

# 查询一个未安装文件在那个包中
repoquery -qf  file-name

docker daemon官方手册
https://docs.docker.com/engine/reference/commandline/dockerd/#run-multiple-daemons
